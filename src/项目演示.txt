1、 首先，我们要会找到spring 项目需要的jar包，并在src目录下创建 applicationContext.xml 配置文件（都可以直接复制）

2、 通过SpringDemo01.java 我们要有够懂得如何通过配置文件告诉spring 容器自动创建 student 对象，并注入我们需要的属性值。
	要求: 【最基本】要会配置 bean 对象
	 	【重要】   理解IOC （控制反转）和 DI（这依赖注入） 的概念和意义 
	 	【重要】  依赖注入的两种方式： 构造方法注入      <constructor-arg >   : 必须提供有参构造
	 				   setter 方法注入   <property >  : 必须提供setXXX() 方法， 注意 property 标签里面的name 要跟XXX对应
	 	
	 	【重要】 注入的类型：
	 			1、 普通值    
	 			2、 引用类型
	 			3、 集合
	 	
	 	 【了解一下】 要会使用    ClassPathXmlApplicationContext 创建spring容器, 并通过容器拿到我们需要的 bean 对象。
	 	 			整合以后，不需要我们这样显示地去创建容器和获取对象。

2、 通过 SpringDemo02.java 演示一下 spring 容器中 bean 的生命周期【要能讲出大概的过程】
			构造方法
			setter 注入
			BeanNameAware  ----> 通知一下你这个对象的 id 是啥
			BeanFactoryAware -----> 通知一下你 beanFactory 对象是啥，但是这个 beanFactory 有什么用不知道
			ApplicationContextAware----> 通知一下你容器的对象是啥，你可以直接从这个容器对象里面获取已经创建好的其他对象
			MyBeanPostProcessor中的 before() 方法-----> 可以对容器中的 bean 对象在其初始化前进行拦截，你可以使用一个代理对象来替换bean对象
			InitializingBean----> 你可以在这个接口的 afterPropertiesSet() 方法中执行一些另外的初始化操作
			自定义的init() 方法执行了！----> 这个方法的方法名是我们自己定义的，但是需要在xml 里面配置 init-method 
			MyBeanPostProcessor中的 after() 方法---->可以对容器中的 bean 对象在其初始化后再一次进行拦截，同样你也可以使用一个代理对象来替换bean 对象
			
			到此阶段， spring 容器中的 bean 对象已经完全初始化完毕！！！ 你可以随意获取并调用bean 对象里面的方法了！！
			
			DisposableBean : 调用destroy() 方法----> 在spring 容器关闭之前，会先调用里面的所有bean 对象的 destroy()方法进行销毁前的一些常规性操作
			自定义的 destroy() 方法执行了！ ----> 这个方法的方法名是我们自己定义的，但是需要在 xml 里面配置 destroy-method
			
3、 这里并不演示注解配置bean 和 依赖注入，但是你要明白下面的这些注解的含义：
	使用注解下面这些注解之前，我们一定要先在配置文件配置下面信息，这样子注解才能生效：
	<context:component-scan base-package="xxxx" />
	<context:annotation-config>
	
	配置bean 对象的注解 【常用】
		@Component
		@Controller
		@Service
		@Repository
		
	配置 setter 注入的注解【常用】 
		@Autowired
		@Qualifier
		@Resource
		
	配置 bean 对象作用域的注解【常用】
		@Scope----->   singleton/ prototype【一定要会】【默认就是单例的，如果配置 struts的action 一定要配置 prototype】
					   request/ session/ globalSession 【了解】
					   
	配置	 @PostConstruct    相当于xml配置自定义的 init 方法：  init-method
		 @PreDestroy       相当于 xml 配置自定义的 destroy 方法： destroy-method	
		 
4、 演示jdk 动态代理 和 cglib 动态代理 如何创建代理对象:
	jdk 动态代理是java 内置的，不需要我们导包，但是要求被代理的对象必须实现某个接口。其基本的思路是： 
		首先，创建一个跟被代理对象实现同一个接口或者同一组接口的对象
			----> 就像是创建一个被代理对象的兄弟，现在被代理对象有什么方法，这个兄弟对象也差不多有什么方法
		然后，通过 invocationhandler 接收一个被代理对象的实例， 对于保留的功能，都可以调用被代理对象的方法来实现，
			对于需要加强的部分，我们再手动去实现
		最后，创建出来的代理对象既有原对象的功能，还有加强的功能。  因为代理对象与被代理对象实现同一组接口，根据多态的原理，
			如果你使用接口类型来接收的话，那么从外表上来看，你看不出代理对象和被代理对象有什么区别。
	
	cglib 动态代理需要我们导包才可以使用，但是导包的麻烦绝对是值得的。 因为 cglib 动态代理比jdk 代理要强大很多。
		jdk 代理要求被代理的对象必须实现某个接口，但是cglib 根本就不需要被代理对象实现什么接口，只要是个对象就可以了。
		cglib 动态代理的基本思路是：
		首先，你得创建一个enhancer  对象，这是cglib 代理的核心类
		然后，你得告诉 enhancer 对象要加强的对象的class 对象是什么， cglib 其实会根据你设置的这个 class 对象去生成一个
			这个类的子类对象，因为是子类对象，所以父类有的方法，只要不是private 修改的方法，子类对象都会有的
		再然后，就是设置回调函数，这个回调函数的大概作用就是： 当你通过最终生成的代理对象去调用方法的时候，最终都是先调用这个回调
			函数，再通过这个回调函数去调用原来对象的本身的方法。 相当于子类对象，全部重写了父类的方法，并在父类方法外面加了一层方法。
			加的这层方法，你可以什么都不干，就调用原来父类的方法
			也可以加一些自己的功能，再调用父类的方法
			也可以完全不用父类的方法，自己来实现
		最后，因为cglib 生成的代理对象是被代理对象的子类对象，所以你可以直接把代理对象强转成 被代理对象的类型。

5、 现在我们熟悉了 jdk 和 cglib 动态代理以后，